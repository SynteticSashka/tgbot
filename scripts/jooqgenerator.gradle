buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.testcontainers:testcontainers:1.17.3'
        classpath 'org.testcontainers:postgresql:1.17.3'
        classpath 'org.postgresql:postgresql:42.2.11'
        classpath 'org.flywaydb:flyway-core:6.3.3'
        classpath 'org.slf4j:slf4j-api:1.7.30'
        classpath 'org.slf4j:jul-to-slf4j:1.7.30'
        classpath 'ch.qos.logback:logback-classic:1.2.3'
        classpath 'ch.qos.logback:logback-core:1.2.3'
        classpath 'org.jooq:jooq-codegen:3.16.6'
    }
}

import org.jooq.meta.jaxb.Database
import org.jooq.meta.jaxb.Generate
import org.jooq.meta.jaxb.Generator
import org.jooq.meta.jaxb.Jdbc
import org.jooq.meta.jaxb.Target
import org.testcontainers.containers.JdbcDatabaseContainer
import org.testcontainers.containers.output.OutputFrame
import org.flywaydb.core.Flyway
import org.jooq.codegen.GenerationTool
import org.jooq.codegen.JavaGenerator
import java.util.stream.Collectors

import org.testcontainers.utility.DockerImageName;

project.configurations.create("dbcontainer")
project.extensions.create("jooq", DockerGeneratorExtension.class)
project.jooq.extensions.create("generate", Generate.class)

task jooqDockerGenerate(type: DockerGeneratorTask) {

}
class DockerGeneratorExtension {
    String basePackageName
    String includeMatches = ".*"
    String inputSchema = "public"
    String excludes = ""
    String databaseGeneratorName = "org.jooq.meta.postgres.PostgresDatabase"
    String imageName = null
    String compatibleImage = null
    String containerClass = "org.testcontainers.containers.PostgreSQLContainer"
}

class DockerGeneratorTask extends DefaultTask {

    @Internal
    final DockerGeneratorExtension extension = project.extensions.getByName("jooq") as DockerGeneratorExtension

    private static final String LINE_BREAK_REGEX = "((\\r?\\n)|(\\r))";
    private static final String LINE_BREAK_AT_END_REGEX = LINE_BREAK_REGEX + '$';
    private static final String FILESYSTEM_PREFIX = "filesystem:";

    @OutputDirectory
    def outputDirectory = project.objects.directoryProperty().convention(project.layout.buildDirectory.dir("generated-jooq"))

    @InputFiles
    def inputDirectory = project.objects.fileCollection().from("src/main/resources/db/migration")

    @TaskAction
    def execute() {
        def loader = buildJdbcArtifactsAwareClassLoader()
        def clazz = Class.forName(
                extension.containerClass, true, loader
        )

        def container = extension.imageName != null ?
                clazz.newInstance(
                        extension.compatibleImage != null ?
                                DockerImageName.parse(extension.imageName).asCompatibleSubstituteFor(extension.compatibleImage)
                                : extension.imageName
                ) :
                clazz.getDeclaredConstructor().newInstance()


        container.withLogConsumer(this.&log)
        container.start()
        try {
            println("Stared: ${container.getFirstMappedPort()}")
            this.migrate(container)
            this.generateJooqClasses(container)
        } finally {
            container.stop()
        }
    }

    void generateJooqClasses(JdbcDatabaseContainer container) {
        new GenerationTool()
                .run(new org.jooq.meta.jaxb.Configuration()
                        .withLogging(org.jooq.meta.jaxb.Logging.DEBUG)
                        .withJdbc(new Jdbc()
                                .withDriver(container.getDriverClassName())
                                .withUrl(container.getJdbcUrl())
                                .withUser(container.getUsername())
                                .withPassword(container.getPassword())
                        ).withGenerator(prepareGeneratorConfig()))
    }

    private Generator prepareGeneratorConfig() {
        return new Generator()
                .withName(JavaGenerator.class.name)
                .withDatabase(new Database()
                        .withName(extension.databaseGeneratorName)
                        .withIncludes(extension.includeMatches)
                        .withInputSchema(extension.inputSchema)
                        .withExcludes(extension.excludes))
                .withTarget(new Target()
                        .withPackageName(extension.basePackageName)
                        .withDirectory(outputDirectory.asFile.get().toString())
                        .withClean(true))
                .withGenerate(extension.generate)
    }


    void migrate(JdbcDatabaseContainer container) {
        def dirs = inputDirectory.asList()
                .stream()
                .map({ FILESYSTEM_PREFIX+it.absolutePath})
                .peek({ println("${it}")})
                .collect(Collectors.toList())
                .toArray(new String[0])

        Flyway.configure().dataSource(container.getJdbcUrl(), container.getUsername(), container.getPassword())
                .locations( dirs )
                .load()
                .migrate()
    }

    void log(OutputFrame outputFrame) {

        OutputFrame.OutputType outputType = outputFrame.getType()

        String utf8String = outputFrame.getUtf8String()
        utf8String = utf8String.replaceAll(LINE_BREAK_AT_END_REGEX, "")

        switch (outputType) {
            case OutputFrame.OutputType.END: break;
            case OutputFrame.OutputType.STDOUT: println(utf8String); break;
            case OutputFrame.OutputType.STDERR: println(utf8String); break;
            default: break;
        }
    }

    private ClassLoader buildJdbcArtifactsAwareClassLoader()  {
        return new URLClassLoader(resolveJdbcArtifacts(), DockerGeneratorTask.class.classLoader)
    }

    private URL[] resolveJdbcArtifacts()  {
        return project.configurations.getByName("dbcontainer")
                .resolvedConfiguration
                .resolvedArtifacts
                .stream()
                .map {
                    it.file.toURI().toURL()
                }.collect(Collectors.toList()).toArray(new URL[0])
    }
}
